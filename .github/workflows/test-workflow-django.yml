name: Run Django Unit Test with Coverage, Check the Migration, Run Sonar and Linting Quality Checks

on:
  workflow_dispatch:
  push:

jobs:
  test:
    name: Django Tests With Postgres and Coverage
    strategy:
      matrix:
        python_version: [ "3.11.2" ]
        poetry_version: [ '1.8.4' ]
    runs-on: ubuntu-latest
    container: python:${{ matrix.python_version }}-alpine

    services:
      postgres:
        image: ${{ (true) && 'postgres:17-alpine' || '' }}  #INPUT
        env:
          POSTGRES_DB: ${{ vars.POSTGRES_DB }}
          POSTGRES_USER: ${{ vars.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install needed apk packages
        run: apk update && apk add bash && apk add zstd && apk add tar

      - name: Load cache
        id: cache
        uses: actions/cache@v4
        with:
          path: |
            django-test/.venv
            /github/home/.local
          key: cache-poetry-${{ matrix.poetry_version }}-python-${{ matrix.python_version }}--${{ hashFiles('**/poetry.lock') }}

      - name: Add cache to path
        if: steps.cache.outputs.cache-hit == 'true'
        run: echo "/github/home/.local/bin" >> $GITHUB_PATH

      - name: Install Poetry V${{ matrix.poetry_version }}
        if: steps.cache.outputs.cache-hit != 'true'
        uses: snok/install-poetry@v1
        with:
          version: ${{ matrix.poetry_version }}
          virtualenvs-create: true
          virtualenvs-in-project: true
          installer-parallel: true

      - name: Poetry; configure and (check) package install
        working-directory: django-test #INPUT
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          INSTALL_MSG=$(poetry install --dry-run 2>&1 | tail -1)
          if [[ "$INSTALL_MSG" != '' ]]; then
            echo "<h2>:no_entry_sign: Poetry install dry-run failed </h2>
                    <h3>You should probably run 'poetry lock' </h3>
                    <br/> $INSTALL_MSG" >> $GITHUB_STEP_SUMMARY
            exit 3
          fi
          poetry config repositories.repowered ${{ secrets.PRIVATE_PYPI_URL}}
          poetry config http-basic.repowered ${{ secrets.PRIVATE_PYPI_USER }} ${{ secrets.PRIVATE_PYPI_PASSWORD}}
          poetry config --list
          poetry install --no-interaction --no-root --no-ansi

#      - name: Check Django Migrations
#        working-directory: django-test #INPUT
#        run: |
#          MIGRATION_MSG=$(poetry run python manage.py makemigrations --dry-run 2>&1 )
#          if [[ "$MIGRATION_MSG" != 'No changes detected' ]]; then
#            echo "<h2>:no_entry_sign: Migration check failed </h2>" >> $GITHUB_STEP_SUMMARY
#            echo "<h3>The message:</h3>" >> $GITHUB_STEP_SUMMARY
#            echo "$MIGRATION_MSG" >> $GITHUB_STEP_SUMMARY
#            exit 3
#          fi
#        env:
#          CI: true
#          SQL_DATABASE: ${{ vars.POSTGRES_DB }}
#          SQL_USER: ${{ vars.POSTGRES_USER }}
#          SQL_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
#          SQL_HOST: ${{ vars.POSTGRES_HOST }}
#          SQL_PORT: 5432

      - name: Run tests with coverage
        working-directory: django-test #INPUT
        # Bash commands explanations:
        # 2>&1: redirect stderr to stdout
        # tee /dev/stderr >test_report: Copy standard input to 'test_report' and to stdout
        # { grep 'failed' || true; }: makes sure that grep does not exit with code 1 when no failures are found
        run: |
          poetry run pytest --cov-config=.coveragerc --cov-report=xml --cov=. --durations=5 --numprocesses=2 2>&1 | tee /dev/stderr >test_report
          HAS_FAILURES=$(cat test_report | { grep 'failed' || true; } 2>&1 )
          if [ -f test_report ]; then
              if [ "$HAS_FAILURES" == '' ]; then
                echo "<details><summary>:white_check_mark: Tests Succeeded</summary>" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                cat test_report >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "</details>" >> $GITHUB_STEP_SUMMARY
              else
                echo "<details><summary>:x: Tests Failed</summary>" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                cat test_report >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo "</details>" >> $GITHUB_STEP_SUMMARY
                exit 3
              fi
          fi
        env:
          CI: true
          COLUMNS: 500
          SQL_DATABASE: ${{ vars.POSTGRES_DB }}
          SQL_USER: ${{ vars.POSTGRES_USER }}
          SQL_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          SQL_HOST: ${{ vars.POSTGRES_HOST }}
#          SQL_PORT: 5432

      - name: Archive test coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage.xml
          path: django-test/
          if-no-files-found: 'error'

#  quality-control-sonar:
#    name: Quality checks via SonarCloud with coverage report
#    continue-on-error: true
#    needs: test
#    steps:
#      - name: Download coverage artifact
#        uses: actions/download-artifact@v4
#        with:
#          name: coverage.xml
#
#      - name: SonarCloud analysis
#        uses: SonarSource/sonarcloud-github-action@master
#        env:
#          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#
#  quality-control-lint:
#    name: Quality checks with black flake8 isort
#    strategy:
#      matrix:
#        python_version: [ "3.11.2" ]
#
#    steps:
#      - name: Checkout Repository
#        uses: actions/checkout@v4
#
#      - name: Setup Python ${{ matrix.python_version }}
#        uses: actions/setup-python@v5
#        with:
#          python_version: ${{ matrix.python_version }}
#          architecture: "x64"
#
#      - name: Load Pip Cache (when it exists)
#        uses: actions/cache@v4
#        id: cached-pip
#        with:
#          path: ~/.cache/pip
#          key: ${{ runner.os }}-pip
#          restore-keys: ${{ runner.os }}-pip
#
#      - name: Install Fresh Linters
#        if: steps.cached-pip.outputs.cache-hit != 'true'
#        run: python -m pip install black flake8 isort
#
#      - name: Run Linters
#      - run: |
#          flake8 .
#          black . --check
#          isort .
